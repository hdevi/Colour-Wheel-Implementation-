/*
 * nan.c
 *
 *  Created on: 27-Jan-2018
 *      Author: HIMAN
 */


/**
*
* @file ece544ip_test.c
*
* @author Nandita Ekbote (enandita@pdx.edu)
* @Referred code from  ece544ip_test.c Getting Started Project authored by Roy Kravitz (roy.kravitz@pdx.edu) and Srivatsa Yogendra (srivatsa@pdx.edu)
*
*
* This file implements a PWM generation and detetction mechannism using the Nexys4IO and custom Pmod peripherals
* used in ECE 544. The peripherals provides access to the Nexys4 pushbuttons
* and slide switches, the LEDs, the RGB LEDs, and the Seven Segment display
* on the Digilent Nexys4 board and the PmodOLEDrgb (94 x 64 RGB graphics display)
* and the PmodENC (rotary encoder + slide swich + pushbutton).
*
* The test is basic but covers all of the API functions:
*	o initialize the Nexys4IO, Pmod drivers and all the other peripherals
*	o Set the tri color LED's to different colors by varrying HSV inputs interfaced from PmodENC and PmodOLEDrgb buttons
*	o Detect the PWM generated by HSV and calculate duty cycles can be set for both RGB LEDs
*	o SW detection of PWM is by FIT and HW detection is  programmed on FPGA
*	o Display to the digits of the seven segment display banks
*
*
*
* @note
* The minimal hardware configuration for this test is a Microblaze-based system with at least 32KB of memory,
* an instance of Nexys4IO, an instance of the pmodOLEDrgb AXI slave peripheral, and instance of the pmodENC AXI
* slave peripheral, an instance of AXI GPIO, an instance of AXI timer and an instance of the AXI UARTLite
* (used for xil_printf() console output)
*
* @note
* The driver code and test application(s) for the pmodOLDrgb are based on code provided by Digilent, Inc.
******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "platform.h"
#include "xparameters.h"
#include "xstatus.h"
#include "microblaze_sleep.h"
#include "nexys4IO.h"
#include "pmodOLEDrgb.h"
#include "pmodENC.h"
#include "xgpio.h"
#include "xintc.h"
#include "xtmrctr.h"

/************************** Constant Definitions ****************************/

// Clock frequencies
#define CPU_CLOCK_FREQ_HZ		XPAR_CPU_CORE_CLOCK_FREQ_HZ
#define AXI_CLOCK_FREQ_HZ		XPAR_CPU_M_AXI_DP_FREQ_HZ

// AXI timer parameters
#define AXI_TIMER_DEVICE_ID		XPAR_AXI_TIMER_0_DEVICE_ID
#define AXI_TIMER_BASEADDR		XPAR_AXI_TIMER_0_BASEADDR
#define AXI_TIMER_HIGHADDR		XPAR_AXI_TIMER_0_HIGHADDR
#define TmrCtrNumber			0


// Definitions for peripheral NEXYS4IO
#define NX4IO_DEVICE_ID		XPAR_NEXYS4IO_0_DEVICE_ID
#define NX4IO_BASEADDR		XPAR_NEXYS4IO_0_S00_AXI_BASEADDR
#define NX4IO_HIGHADDR		XPAR_NEXYS4IO_0_S00_AXI_HIGHADDR

// Definitions for peripheral PMODOLEDRGB
#define RGBDSPLY_DEVICE_ID		XPAR_PMODOLEDRGB_0_DEVICE_ID
#define RGBDSPLY_GPIO_BASEADDR	XPAR_PMODOLEDRGB_0_AXI_LITE_GPIO_BASEADDR
#define RGBDSPLY_GPIO_HIGHADDR	XPAR_PMODOLEDRGB_0_AXI_LITE_GPIO_HIGHADD
#define RGBDSPLY_SPI_BASEADDR	XPAR_PMODOLEDRGB_0_AXI_LITE_SPI_BASEADDR
#define RGBDSPLY_SPI_HIGHADDR	XPAR_PMODOLEDRGB_0_AXI_LITE_SPI_HIGHADDR

// Definitions for peripheral PMODENC
#define PMODENC_DEVICE_ID		XPAR_PMODENC_0_DEVICE_ID
#define PMODENC_BASEADDR		XPAR_PMODENC_0_S00_AXI_BASEADDR
#define PMODENC_HIGHADDR		XPAR_PMODENC_0_S00_AXI_HIGHADDR

// Fixed Interval timer - 100 MHz input clock, 40KHz output clock
// FIT_COUNT_1MSEC = FIT_CLOCK_FREQ_HZ * .001
#define FIT_IN_CLOCK_FREQ_HZ	CPU_CLOCK_FREQ_HZ
#define FIT_CLOCK_FREQ_HZ		40000
#define FIT_COUNT				(FIT_IN_CLOCK_FREQ_HZ / FIT_CLOCK_FREQ_HZ)
#define FIT_COUNT_1MSEC			40

// GPIO parameters
#define GPIO_0_DEVICE_ID			XPAR_AXI_GPIO_0_DEVICE_ID
#define GPIO_0_INPUT_0_CHANNEL		1
#define GPIO_0_OUTPUT_0_CHANNEL		2

// GPIO parameters
#define GPIO_1_DEVICE_ID			XPAR_AXI_GPIO_1_DEVICE_ID
#define GPIO_1_INPUT_1_CHANNEL		1
#define GPIO_1_INPUT_2_CHANNEL		2

// GPIO parameters
#define GPIO_2_DEVICE_ID			XPAR_AXI_GPIO_2_DEVICE_ID
#define GPIO_2_INPUT_1_CHANNEL		1
#define GPIO_2_INPUT_2_CHANNEL		2

// GPIO parameters
#define GPIO_3_DEVICE_ID			XPAR_AXI_GPIO_3_DEVICE_ID
#define GPIO_3_INPUT_1_CHANNEL		1
#define GPIO_3_INPUT_2_CHANNEL		2

// Interrupt Controller parameters
#define INTC_DEVICE_ID			XPAR_INTC_0_DEVICE_ID
#define FIT_INTERRUPT_ID		XPAR_MICROBLAZE_0_AXI_INTC_FIT_TIMER_0_INTERRUPT_INTR

/**************************** Type Definitions ******************************/

/***************** Macros (Inline Functions) Definitions ********************/

/************************** Variable Definitions ****************************/
// Microblaze peripheral instances
uint64_t 	timestamp = 0L;
PmodOLEDrgb	pmodOLEDrgb_inst;
PmodENC 	pmodENC_inst;
XGpio		GPIOInst0,GPIOInst1,GPIOInst2,GPIOInst3;					// GPIO instance
XIntc 		IntrptCtlrInst;				// Interrupt Controller instance
XTmrCtr		AXITimerInst;				// PWM timer instance


// The following variables are shared between non-interrupt processing and
// interrupt processing such that they must be global(and declared volatile)
// These variables are controlled by the FIT timer interrupt handler


volatile u32			gpio_in;			// GPIO input port

/************* Functionality related variables ******************/
u16 RotaryCnt;
u8 DC_Red= 0, DC_Green =0, DC_Blue= 0;
volatile u8 HW_DC_Red= 0, HW_DC_Green =0, HW_DC_Blue= 0;
volatile u8 HSV_Hue = 0, HSV_Value, HSV_Saturation;
u16 RGB_565 = 0;
static u32 old_gpio_in = 0;
static	u32 OnTime_Red_Counter = 0, OffTime_Red_Counter = 0, OnTime_Green_Counter = 0, OffTime_Green_Counter = 0, OnTime_Blue_Counter = 0, OffTime_Blue_Counter = 0;
u32			SW_OnTime_Red = 0;			/* SW on time for Red*/
u32		    SW_OffTime_Red = 0;			/* SW off time for Red*/
u32			SW_OnTime_Blue = 0;			/* SW on time for Blue*/
u32			SW_OffTime_Blue = 0;		/*SW off time for Blue*/
u32			SW_OnTime_Green = 0;		/*SW on time for Green*/
u32			SW_OffTime_Green = 0;		/*SW off time for Green*/
volatile u32			HW_OnTime_Red = 0;			/*SW on time for Red*/
volatile u32			HW_OffTime_Red = 0;			/*SW off time for Red*/
volatile u32			HW_OnTime_Blue = 0;			/*SW on time for Blue*/
volatile u32			HW_OffTime_Blue = 0;		/*SW off time for Blue*/
volatile u32			HW_OnTime_Green = 0;		/*SW on time for Green*/
volatile u32			HW_OffTime_Green = 0;		/*SW off time for Green*/

/************************** Function Prototypes *****************************/
void PMDIO_itoa(int32_t value, char *string, int32_t radix);
void PMDIO_puthex(PmodOLEDrgb* InstancePtr, uint32_t num);
void PMDIO_putnum(PmodOLEDrgb* InstancePtr, int32_t num, int32_t radix);
int	 do_init(void);											// initialize system
void FIT_Handler(void);										// fixed interval timer interrupt handler
int AXI_Timer_initialize(void);

/************ Functionality related function prototype *********************/
void PWM_Generation_Detection(void);

/************************** MAIN PROGRAM ************************************/
int main(void)
{
    init_platform();  /* Enables Cache and UART */

	uint32_t sts;

	sts = do_init();
	if (XST_SUCCESS != sts)
	{
		exit(1);
	}

	/* start by enabling the Microblaze interrupt  */
	microblaze_enable_interrupts();

	xil_printf("ECE 544 PWM generate and detect implementation\n\r");
	xil_printf("By Nandita. 20-Jan-2018\n\n\r");

	/* PWM generation and detection */
	PWM_Generation_Detection();

	NX410_SSEG_setAllDigits(SSEGLO, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
	NX410_SSEG_setAllDigits(SSEGHI, CC_BLANK, CC_BLANK, CC_BLANK, CC_BLANK, DP_NONE);
	OLEDrgb_Clear(&pmodOLEDrgb_inst);
	OLEDrgb_end(&pmodOLEDrgb_inst);
	NX4IO_RGBLED_setChnlEn(RGB1, false, false, false);
	NX4IO_RGBLED_setChnlEn(RGB2, false, false, false);

	// cleanup and exit
	cleanup_platform();
	exit(0);
}

void PWM_Generation_Detection(void)
{
	uint16_t sw;
	uint16_t RotaryCnt, OldRotaryCnt;
	uint16_t RotaryIncr;
	bool RotaryNoNeg;

	/* Pmod Encoder variables*/
	RotaryIncr = 1;
	RotaryNoNeg = false;
	pmodENC_init(&pmodENC_inst, RotaryIncr, RotaryNoNeg);
	pmodENC_clear_count(&pmodENC_inst);
	OldRotaryCnt = 0xFFFF;
	HSV_Value = 255;
	HSV_Saturation = 255;

	OLEDrgb_Clear(&pmodOLEDrgb_inst);
	OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(200, 12, 44));
	OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, 1);
	OLEDrgb_PutString(&pmodOLEDrgb_inst,"H=");
	OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, 3);
	OLEDrgb_PutString(&pmodOLEDrgb_inst,"S=");
	OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, 5);
	OLEDrgb_PutString(&pmodOLEDrgb_inst,"V=");

	/* PWM Generation and detection*/
	while (1)
	{
		/* Exit the loop if either one is pressed */
		if (pmodENC_is_button_pressed(&pmodENC_inst) )
		{
			OLEDrgb_Clear(&pmodOLEDrgb_inst);
			break;
		}

		if (NX4IO_isPressed(BTNC))
		{
			OLEDrgb_Clear(&pmodOLEDrgb_inst);
			break;
		}

		/* Get the rotary count and update the display with the Hue value */
		pmodENC_read_count(&pmodENC_inst, &RotaryCnt);
		OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(200, 12, 44));
		{
			HSV_Hue = RotaryCnt;
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 1);
			OLEDrgb_PutString(&pmodOLEDrgb_inst,"   ");
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 1);
			PMDIO_putnum(&pmodOLEDrgb_inst, HSV_Hue, 10);
		}

		/* Read Saturation and Value from buttons on Nexys4DDR */
		/* Buttons R and L for Value in HSV */
		if(NX4IO_isPressed(BTNR))
		{
			HSV_Value++;

		}
		else if(NX4IO_isPressed(BTNL))
		{
			HSV_Value--;

		}
		 /* Display Value on OLed */
		{
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 5);
			OLEDrgb_PutString(&pmodOLEDrgb_inst,"   ");
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 5);
			PMDIO_putnum(&pmodOLEDrgb_inst, HSV_Value, 10);
		}


		/* Buttons U and D for Saturation in HSV */
		if(NX4IO_isPressed(BTNU))
		{
			HSV_Saturation++;

		}
		else if(NX4IO_isPressed(BTND))
		{
			HSV_Saturation--;

		}
		/* Display Saturation on OLed */
		{

			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 3);
			OLEDrgb_PutString(&pmodOLEDrgb_inst,"   ");
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 4, 3);
			PMDIO_putnum(&pmodOLEDrgb_inst, HSV_Saturation, 10);
		}

		/* Convert HSV to 565 RGB */
		RGB_565 = OLEDrgb_BuildHSV(HSV_Hue,HSV_Value,HSV_Saturation);

		/*  Enable all three PWM channels and display on RGB1 */
		NX4IO_RGBLED_setChnlEn(RGB1, true, true, true);
		NX4IO_RGBLED_setDutyCycle(RGB1, ((uint8_t)((RGB_565 & 0xF800)>>11))<<3, ((uint8_t)((RGB_565 & 0x07E0)>>5))<<2, ((uint8_t)(RGB_565 & 0x001F))<<3);
		usleep(10*1000);   // HOW TO DEICDE Delay

		/*  Enable all three PWM channels and display on RGB2  */
		NX4IO_RGBLED_setChnlEn(RGB2, true, true, true);
		NX4IO_RGBLED_setDutyCycle(RGB2,((uint8_t)((RGB_565 & 0xF800)>>11))<<3, ((uint8_t)((RGB_565 & 0x07E0)>>5))<<2, ((uint8_t)(RGB_565 & 0x001F))<<3);
		usleep(10*1000);   // HOW TO DEICDE Delay

		/* Draw Square */
		OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,RGB_565);
		OLEDrgb_DrawRectangle(&pmodOLEDrgb_inst, 75, 20, 95, 40, RGB_565, true, RGB_565);

		/* Decide whether SW or HW detection method is to be used. sw[0]=1 selects HW and sw[0]=0 selects SW detect*/
		sw = NX4IO_getSwitches();

		if(sw & 0x01)
		{
			 /*HW Duty Cycle Detection*/
			NX4IO_setLEDs(NX4IO_getLEDS_DATA()|0x01);
			/* Read counts from GPIO **/
			usleep(10*1000);   // HOW TO DEICDE Delay
			HW_OnTime_Red = XGpio_DiscreteRead(&GPIOInst1, GPIO_1_INPUT_1_CHANNEL);
			HW_OffTime_Red = XGpio_DiscreteRead(&GPIOInst1, GPIO_1_INPUT_2_CHANNEL);
			HW_OnTime_Green = XGpio_DiscreteRead(&GPIOInst2, GPIO_2_INPUT_1_CHANNEL);
			HW_OffTime_Green = XGpio_DiscreteRead(&GPIOInst2, GPIO_2_INPUT_2_CHANNEL);
			HW_OnTime_Blue = XGpio_DiscreteRead(&GPIOInst3, GPIO_3_INPUT_1_CHANNEL);
			HW_OffTime_Blue = XGpio_DiscreteRead(&GPIOInst3, GPIO_3_INPUT_2_CHANNEL);
			/* Calculate Duty Cycle */
			HW_DC_Red = (HW_OnTime_Red * 100) / (HW_OnTime_Red + HW_OffTime_Red);
			HW_DC_Green = (HW_OnTime_Green * 100) / (HW_OnTime_Green + HW_OffTime_Green);
			HW_DC_Blue = (HW_OnTime_Blue * 100) / (HW_OnTime_Blue + HW_OffTime_Blue);

			OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(200, 12, 44));
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, 15);
			OLEDrgb_PutString(&pmodOLEDrgb_inst,"HW Dct");
			/* Display on 7-segment*/
					NX4IO_SSEG_setDigit(SSEGHI, DIGIT7, (HW_DC_Red/10)); /* Display ten's place digit */
					NX4IO_SSEG_setDigit(SSEGHI, DIGIT6,(HW_DC_Red%10)); /* Display unit's place digit */
					NX4IO_SSEG_setDigit(SSEGHI, DIGIT5, CC_BLANK);
					NX4IO_SSEG_setDigit(SSEGHI, DIGIT4, (HW_DC_Green/10));
					NX4IO_SSEG_setDigit(SSEGLO, DIGIT3, (HW_DC_Green%10));
					NX4IO_SSEG_setDigit(SSEGLO, DIGIT2, CC_BLANK);
					NX4IO_SSEG_setDigit(SSEGLO, DIGIT1, (HW_DC_Blue/10));
					NX4IO_SSEG_setDigit(SSEGLO, DIGIT0, (HW_DC_Blue%10));
		}
		else
		{
			/* SW Duty Cycle Detection */
			NX4IO_setLEDs(NX4IO_getLEDS_DATA()&0xFFFE);
			/* Calculate Duty Cycle */
			DC_Red = (SW_OnTime_Red * 100) / (SW_OnTime_Red + SW_OffTime_Red);
			DC_Green = (SW_OnTime_Green * 100) / (SW_OnTime_Green + SW_OffTime_Green);
			DC_Blue = (SW_OnTime_Blue * 100) / (SW_OnTime_Blue + SW_OffTime_Blue);

			OLEDrgb_SetFontColor(&pmodOLEDrgb_inst,OLEDrgb_BuildRGB(200, 12, 44));
			OLEDrgb_SetCursor(&pmodOLEDrgb_inst, 1, 15);
			OLEDrgb_PutString(&pmodOLEDrgb_inst,"SW Dct");

		/* Display on 7-segment*/
		NX4IO_SSEG_setDigit(SSEGHI, DIGIT7, (DC_Red/10)); /* Display ten's place digit */
		NX4IO_SSEG_setDigit(SSEGHI, DIGIT6,(DC_Red%10)); /* Display unit's place digit */
		NX4IO_SSEG_setDigit(SSEGHI, DIGIT5, CC_BLANK);
		NX4IO_SSEG_setDigit(SSEGHI, DIGIT4, (DC_Green/10));
		NX4IO_SSEG_setDigit(SSEGLO, DIGIT3, (DC_Green%10));
		NX4IO_SSEG_setDigit(SSEGLO, DIGIT2, CC_BLANK);
		NX4IO_SSEG_setDigit(SSEGLO, DIGIT1, (DC_Blue/10));
		NX4IO_SSEG_setDigit(SSEGLO, DIGIT0, (DC_Blue%10));
		}
	}
	return;
}


/**************************** HELPER FUNCTIONS ******************************/

/****************************************************************************/
/**
* initialize the system
*
* This function is executed once at start-up and after resets.  It initializes
* the peripherals and registers the interrupt handler(s)
*****************************************************************************/

int	 do_init(void)
{
	uint32_t status;				// status from Xilinx Lib calls

	// initialize the Nexys4 driver and (some of)the devices
	status = (uint32_t) NX4IO_initialize(NX4IO_BASEADDR);
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}

	// set all of the display digits to blanks and turn off
	// the decimal points using the "raw" set functions.
	// These registers are formatted according to the spec
	// and should remain unchanged when written to Nexys4IO...
	// something else to check w/ the debugger when we bring the
	// drivers up for the first time
	NX4IO_SSEG_setSSEG_DATA(SSEGHI, 0x0058E30E);
	NX4IO_SSEG_setSSEG_DATA(SSEGLO, 0x00144116);

	OLEDrgb_begin(&pmodOLEDrgb_inst, RGBDSPLY_GPIO_BASEADDR, RGBDSPLY_SPI_BASEADDR);

	// initialize the pmodENC and hardware
	status = pmodENC_initialize(&pmodENC_inst, PMODENC_BASEADDR);
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}

	// initialize the GPIO instances
	/* GPIO0 */
	status = XGpio_Initialize(&GPIOInst0, GPIO_0_DEVICE_ID);
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}
	// GPIO0 channel 1 is an 8-bit input port.
	// GPIO0 channel 2 is an 8-bit output port.
	XGpio_SetDataDirection(&GPIOInst0, GPIO_0_INPUT_0_CHANNEL, 0xFF);
	XGpio_SetDataDirection(&GPIOInst0, GPIO_0_OUTPUT_0_CHANNEL, 0x00);

	/* GPIO1 */
		status = XGpio_Initialize(&GPIOInst1, GPIO_1_DEVICE_ID);
		if (status != XST_SUCCESS)
		{
			return XST_FAILURE;
		}
		// GPIO1 channel 1 is an 32-bit input port.
		// GPIO1 channel 2 is an 32-bit output port.
		XGpio_SetDataDirection(&GPIOInst1, GPIO_1_INPUT_1_CHANNEL, 0xFFFF);
		XGpio_SetDataDirection(&GPIOInst1, GPIO_1_INPUT_2_CHANNEL, 0xFFFF);

		/* GPIO2 */
		status = XGpio_Initialize(&GPIOInst2, GPIO_2_DEVICE_ID);
		if (status != XST_SUCCESS)
		{
			return XST_FAILURE;
		}
		// GPIO2 channel 1 is an 32-bit input port.
		// GPIO2 channel 2 is an 32-bit output port.
		XGpio_SetDataDirection(&GPIOInst2, GPIO_2_INPUT_1_CHANNEL, 0xFFFF);
		XGpio_SetDataDirection(&GPIOInst2, GPIO_2_INPUT_2_CHANNEL, 0xFFFF);

		/* GPIO3 */
		status = XGpio_Initialize(&GPIOInst3, GPIO_3_DEVICE_ID);
		if (status != XST_SUCCESS)
		{
			return XST_FAILURE;
		}
		// GPIO3 channel 1 is an 32-bit input port.
		// GPIO3 channel 2 is an 32-bit output port.
		XGpio_SetDataDirection(&GPIOInst3, GPIO_3_INPUT_1_CHANNEL, 0xFFFF);
		XGpio_SetDataDirection(&GPIOInst3, GPIO_3_INPUT_2_CHANNEL, 0xFFFF);

	status = AXI_Timer_initialize();
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}

	// initialize the interrupt controller
	status = XIntc_Initialize(&IntrptCtlrInst, INTC_DEVICE_ID);
	if (status != XST_SUCCESS)
	{
	   return XST_FAILURE;
	}

	// connect the fixed interval timer (FIT) handler to the interrupt
	status = XIntc_Connect(&IntrptCtlrInst, FIT_INTERRUPT_ID,
						   (XInterruptHandler)FIT_Handler,
						   (void *)0);
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;

	}

	// start the interrupt controller such that interrupts are enabled for
	// all devices that cause interrupts.
	status = XIntc_Start(&IntrptCtlrInst, XIN_REAL_MODE);
	if (status != XST_SUCCESS)
	{
		return XST_FAILURE;
	}

	// enable the FIT interrupt
	XIntc_Enable(&IntrptCtlrInst, FIT_INTERRUPT_ID);
	return XST_SUCCESS;
}
/*
 * AXI timer initializes it to generate out a 4Khz signal, Which is given to the Nexys4IO module as clock input.
 * DO NOT MODIFY
 */
int AXI_Timer_initialize(void){

	uint32_t status;				// status from Xilinx Lib calls
	u32		ctlsts;		// control/status register or mask

	status = XTmrCtr_Initialize(&AXITimerInst,AXI_TIMER_DEVICE_ID);
		if (status != XST_SUCCESS) {
			return XST_FAILURE;
		}
	status = XTmrCtr_SelfTest(&AXITimerInst, TmrCtrNumber);
		if (status != XST_SUCCESS) {
			return XST_FAILURE;
		}
	ctlsts = XTC_CSR_AUTO_RELOAD_MASK | XTC_CSR_EXT_GENERATE_MASK | XTC_CSR_LOAD_MASK |XTC_CSR_DOWN_COUNT_MASK ;
	XTmrCtr_SetControlStatusReg(AXI_TIMER_BASEADDR, TmrCtrNumber,ctlsts);

	//Set the value that is loaded into the timer counter and cause it to be loaded into the timer counter
	XTmrCtr_SetLoadReg(AXI_TIMER_BASEADDR, TmrCtrNumber, 24998);
	XTmrCtr_LoadTimerCounterReg(AXI_TIMER_BASEADDR, TmrCtrNumber);
	ctlsts = XTmrCtr_GetControlStatusReg(AXI_TIMER_BASEADDR, TmrCtrNumber);
	ctlsts &= (~XTC_CSR_LOAD_MASK);
	XTmrCtr_SetControlStatusReg(AXI_TIMER_BASEADDR, TmrCtrNumber, ctlsts);

	ctlsts = XTmrCtr_GetControlStatusReg(AXI_TIMER_BASEADDR, TmrCtrNumber);
	ctlsts |= XTC_CSR_ENABLE_TMR_MASK;
	XTmrCtr_SetControlStatusReg(AXI_TIMER_BASEADDR, TmrCtrNumber, ctlsts);

	XTmrCtr_Enable(AXI_TIMER_BASEADDR, TmrCtrNumber);
	return XST_SUCCESS;

}

/*********************** DISPLAY-RELATED FUNCTIONS ***********************************/

/****************************************************************************/
/**
* Converts an integer to ASCII characters
*
* algorithm borrowed from ReactOS system libraries
*
* Converts an integer to ASCII in the specified base.  Assumes string[] is
* long enough to hold the result plus the terminating null
*
* @param 	value is the integer to convert
* @param 	*string is a pointer to a buffer large enough to hold the converted number plus
*  			the terminating null
* @param	radix is the base to use in conversion,
*
* @return  *NONE*
*
* @note
* No size check is done on the return string size.  Make sure you leave room
* for the full string plus the terminating null in string
*****************************************************************************/
void PMDIO_itoa(int32_t value, char *string, int32_t radix)
{
	char tmp[33];
	char *tp = tmp;
	int32_t i;
	uint32_t v;
	int32_t  sign;
	char *sp;

	if (radix > 36 || radix <= 1)
	{
		return;
	}

	sign = ((10 == radix) && (value < 0));
	if (sign)
	{
		v = -value;
	}
	else
	{
		v = (uint32_t) value;
	}

  	while (v || tp == tmp)
  	{
		i = v % radix;
		v = v / radix;
		if (i < 10)
		{
			*tp++ = i+'0';
		}
		else
		{
			*tp++ = i + 'a' - 10;
		}
	}
	sp = string;

	if (sign)
		*sp++ = '-';

	while (tp > tmp)
		*sp++ = *--tp;
	*sp = 0;

  	return;
}


/****************************************************************************/
/**
* Write a 32-bit unsigned hex number to PmodOLEDrgb in Hex
*
* Writes  32-bit unsigned number to the pmodOLEDrgb display starting at the current
* cursor position.
*
* @param num is the number to display as a hex value
*
* @return  *NONE*
*
* @note
* No size checking is done to make sure the string will fit into a single line,
* or the entire display, for that matter.  Watch your string sizes.
*****************************************************************************/
void PMDIO_puthex(PmodOLEDrgb* InstancePtr, uint32_t num)
{
  char  buf[9];
  int32_t   cnt;
  char  *ptr;
  int32_t  digit;

  ptr = buf;
  for (cnt = 7; cnt >= 0; cnt--) {
    digit = (num >> (cnt * 4)) & 0xF;

    if (digit <= 9)
	{
      *ptr++ = (char) ('0' + digit);
	}
    else
	{
      *ptr++ = (char) ('a' - 10 + digit);
	}
  }

  *ptr = (char) 0;
  OLEDrgb_PutString(InstancePtr,buf);

  return;
}


/****************************************************************************/
/**
* Write a 32-bit number in Radix "radix" to LCD display
*
* Writes a 32-bit number to the LCD display starting at the current
* cursor position. "radix" is the base to output the number in.
*
* @param num is the number to display
*
* @param radix is the radix to display number in
*
* @return *NONE*
*
* @note
* No size checking is done to make sure the string will fit into a single line,
* or the entire display, for that matter.  Watch your string sizes.
*****************************************************************************/
void PMDIO_putnum(PmodOLEDrgb* InstancePtr, int32_t num, int32_t radix)
{
  char  buf[16];

  PMDIO_itoa(num, buf, radix);
  OLEDrgb_PutString(InstancePtr,buf);

  return;
}


/**************************** INTERRUPT HANDLERS ******************************/

/****************************************************************************/
/**
* Fixed interval timer interrupt handler
*
* Reads the GPIO port which reads back the hardware generated PWM wave for the RGB Leds
*
* @note
* ECE 544 students - When you implement your software solution for pulse width detection in
* Project 1 this could be a reasonable place to do that processing.
 *****************************************************************************/

void FIT_Handler(void)
{

	/* Read the GPIO port to read back the generated PWM signal for RGB led's */
	gpio_in = XGpio_DiscreteRead(&GPIOInst0, GPIO_0_INPUT_0_CHANNEL);


	if(gpio_in & 0x00000004)		 /*On time of Red*/
	{
		if((old_gpio_in & 0x00000004) != (gpio_in & 0x00000004))   /*Transiiton from 0 to 1 on Red*/
		{
			SW_OnTime_Red = OnTime_Red_Counter;
			OnTime_Red_Counter = 1;
		}
		else
		{
			OnTime_Red_Counter++;
		}
	}
	else							 /*Off time of Red*/
	{
		if((old_gpio_in & 0x00000004) != (gpio_in & 0x00000004))   /*Transiiton from 1 to 0 on Red*/
		{
			SW_OffTime_Red = OffTime_Red_Counter;
			OffTime_Red_Counter = 1;
		}
		else
		{
			OffTime_Red_Counter++;
		}
	}

	/* Calculate the Duty Cycle of Green */
	if(gpio_in & 0x00000001)		/* On time of Green */
	{
		if((old_gpio_in & 0x00000001) != (gpio_in & 0x00000001))  /* Transiiton from 0 to 1 on Green */
		{
			SW_OnTime_Green = OnTime_Green_Counter;
			OnTime_Green_Counter = 1;
		}
		else
			OnTime_Green_Counter++;
	}
	else							/* Off time of Green */
	{
		if((old_gpio_in & 0x00000001) != (gpio_in & 0x00000001))  /* Transiiton from 1 to 0 on Green */
		{
			SW_OffTime_Green = OffTime_Green_Counter;
			OffTime_Green_Counter = 1;
		}
		else
			OffTime_Green_Counter++;
	}

	/* Calculate the Duty Cycle of Blue */
	if(gpio_in & 0x00000002)		/* On time of Red */
	{
		if((old_gpio_in & 0x00000002) != (gpio_in & 0x00000002))  /* Transiiton from 0 to 1 on Blue */
		{
			SW_OnTime_Blue = OnTime_Blue_Counter;
			OnTime_Blue_Counter = 1;
		}
		else
			OnTime_Blue_Counter++;
	}
	else							/* Off time of Blue */
	{
		if((old_gpio_in & 0x00000002) != (gpio_in & 0x00000002))  /* Transiiton from 1 to 0 on Blue */
		{
			SW_OffTime_Blue = OffTime_Blue_Counter;
			OffTime_Blue_Counter = 1;
		}
		else
			OffTime_Blue_Counter++;
	}
	old_gpio_in = gpio_in;
}

